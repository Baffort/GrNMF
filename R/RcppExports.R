# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' GrNMF is an R/C++ implementation of Non-negative Matrix Factorization on Manifold
#' 
#' \code{GrNMF} Graphically constrained NMF
#' @importFrom Rcpp evalCpp
#' @import RcppArmadillo
#' @useDynLib GrNMF
#' @param Xr an p by n numeric matrix with each column being a feature vector, and each row being a sample vector
#' @param Wr a symmetric numeric matrix (p by p) with 1 iff xi/xj are nearest neighbors (you decide/compute this in advance, 11 is a good neighbor threshold) on a graph, and 0 otherwise.
#' @param lambda the weight to give to the Wr matrix in the NMF minimization. Lambda=0 means standard NMF (Lee's 2001 algorithm).
#' @param k the number of inner dimensions (reduced features, or 'rank') to use for the NMF algorithm
#' @param n_iter the number of optimization loop iterations.
#' @param converge threshold for convergence test for early termination. Negative values deactivate this feature. 
#' @return a list of \code{U}, 
#'   (sometimes called \code{W}) and \code{V} 
#'   (sometimes called \code{H}) for the NNLS fit.
#'   \code{Max.iter} which stores the maximum iteration before NMF converged 
#'   Additionally the standard NMF objective 
#'   function fit is returned as \code{ObjectiveFitNMF}.
#'   The full GrNMF objective function score is retured as
#'   \code{ObjectiveFitGrNMF}
#' @seealso see \code{\link{NMF}}
#' @references Cai, D., He, X., Wu, X., & Han, J. (2008). Non-negative Matrix Factorization on Manifold. 2008 Eighth IEEE International Conference on Data Mining (ICDM), 63â€“72. doi:10.1109/ICDM.2008.57
#' @export
#' @examples
#' # generate a synthetic dataset with known classes: 50 features, 23 samples (10+5+8)
#' \dontrun{
#' library(NMF)
#' n <- 100; counts <- c(10, 7, 3);
#' p <- sum(counts)
#' x <- syntheticNMF(n, counts)
#' dim(x)
#' # build the true cluster membership
#' groups <- unlist(mapply(rep, seq(counts), counts))
#' # run on a data.frame
#' set.seed(10)
#' system.time(res <- nmf(data.frame(x), 3, nmfAlgorithm("lee"), "random"))
#' 
#' 
#' # Now do the same for GrNMF
#' adj2=matrix(1,p,p) #dummy matrix of proper dimensions, not used since lambda=0
#' set.seed(10)
#' 
#' # turn off the graphical part for this comparison
#' # by setting lambda to 0
#' system.time(res2<-GrNMF(x,adj2,lambda=0,k=3))
#' 
#' ##
#' # now we can compare the two fits to the NMF
#' # objective function
#' 
#' # first from the NMF package
#' norm(as.matrix(data.frame(x)- (res@@fit@@W %*% res@@fit@@H)),'F')
#' # and next from GrNMF package
#' res2$ObjectiveFitNMF
#' }
GrNMF <- function(Xr, Wr, k = 5L, lambda = 100L, n_iter = 5000L, converge = 1e-6) {
    .Call('GrNMF_GrNMF', PACKAGE = 'GrNMF', Xr, Wr, k, lambda, n_iter, converge)
}

